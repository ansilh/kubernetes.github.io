<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.121.1"><meta name=generator content="Relearn 5.23.2+tip"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Kubernetes pocket gude and more"><meta name=author content="Ansil H"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kubernetes.ansilh.com/images/hero.png"><meta name=twitter:title content="Introduction :: Hugo Relearn Theme"><meta name=twitter:description content="Kubernetes pocket gude and more"><meta property="og:title" content="Introduction :: Hugo Relearn Theme"><meta property="og:description" content="Kubernetes pocket gude and more"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.ansilh.com/01-introduction/index.html"><meta property="og:image" content="https://kubernetes.ansilh.com/images/hero.png"><meta property="og:site_name" content="Hugo Relearn Theme"><title>Introduction :: Hugo Relearn Theme</title>
<link href=../images/favicon.png?1704656418 rel=icon type=image/png><link href=../css/fontawesome-all.min.css?1704656421 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/fontawesome-all.min.css?1704656421 rel=stylesheet></noscript><link href=../css/nucleus.css?1704656421 rel=stylesheet><link href=../css/auto-complete.css?1704656421 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/auto-complete.css?1704656421 rel=stylesheet></noscript><link href=../css/perfect-scrollbar.min.css?1704656421 rel=stylesheet><link href=../css/fonts.css?1704656421 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../css/fonts.css?1704656421 rel=stylesheet></noscript><link href=../css/theme.css?1704656421 rel=stylesheet><link href=../css/theme-neon.css?1704656421 rel=stylesheet id=R-variant-style><link href=../css/chroma-neon.css?1704656421 rel=stylesheet id=R-variant-chroma-style><link href=../css/variant.css?1704656421 rel=stylesheet><link href=../css/print.css?1704656421 rel=stylesheet media=print><link href=../css/format-print.css?1704656421 rel=stylesheet><link href=../css/ie.css?1704656421 rel=stylesheet><script src=../js/url.js?1704656421></script><script src=../js/variant.js?1704656421></script><script>window.index_js_url="../index.search.js";var root_url="../",baseUri=root_url.replace(/\/$/,"");window.relearn=window.relearn||{},window.relearn.baseUriFull="https://kubernetes.ansilh.com/",window.relearn.themeVariantModifier="",window.variants&&variants.init(["neon"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><style>#R-body img.bg-white{background-color:#fff}</style></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=../01-introduction/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Introduction</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 1</div><h1 id=introduction>Introduction</h1><h4 id=history-of-k8s>History of K8S</h4><div style=float:left><li>2003-2004: Google introduced Borg system , which started as a small project to manage new search engine.
Later on it was heavily used for managing internal distributed systems and jobs<li>2013: Google moved from Borg to Omega - a flexible and scalable scheduler for large clusters<li>2014: Google introduced kubernetes and big players (IBM, Docker, RedHat, Microsoft) joined the project<li>2015: Kubernetes 1.0 released and Google partnered with Linux Foundation to form the Cloud Native Computing Foundation (CNCF)<li>2016: Kubernetes went to mainstream and Helm package manager introduced and `minikube` was also released. Windows support added to k8s<li>2017: Kubernetes reached v.1.7 and were widely adopted by industry. IBM and Google introduced `Istio` service mesh.<li>2018: Industry understands the power of k8s and adoption rate increased<li>2019: Journey continues...</div><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Introduction</h1><article class=default><header class=headline></header><h1 id=linux-kernel-architecture>Linux Kernel Architecture</h1><p><img src=../01-introduction/01-linux-kernel/kernel-architecture.png alt=Kernel class="figure-image nobg-white noborder nolightbox shadow" style=height:auto;width:auto loading=lazy></p><p>At the top is the user, or application, space. This is where the user applications are executed.
Below the user space is the kernel space.</p><p>There is also the GNU C Library (glibc). This provides the system call interface that connects to the kernel and provides the mechanism to transition between the user-space application and the kernel. This is important because the kernel and user application occupy different protected address spaces. And while each user-space process occupies its own virtual address space, the kernel occupies a single address space.</p><p>The Linux kernel can be further divided into three gross levels.</p><ul><li>At the top is the system call interface, which implements the basic functions such as read and write.</li><li>Below the system call interface is the kernel code, which can be more accurately defined as the architecture-independent kernel code. This code is common to all of the processor architectures supported by Linux.</li><li>Below this is the architecture-dependent code, which forms what is more commonly called a BSP (Board Support Package). This code serves as the processor and platform-specific code for the given architecture.</li></ul><p>The Linux kernel implements a number of important architectural attributes. At a high level, and at lower levels, the kernel is layered into a number of distinct subsystems.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=linux-namespaces>Linux Namespaces</h1><p>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same name space for these resources in the various sets of processes, but those names referring to distinct resources. Examples of resource names that can exist in multiple spaces, so that the named resources are partitioned, are process IDs, hostnames, user IDs, file names, and some names associated with network access, and interprocess communication.</p><p>Namespaces are a fundamental aspect of containers on Linux.</p><table><thead><tr><th>Namespace</th><th>Constant</th><th>Isolates</th></tr></thead><tbody><tr><td>Cgroup</td><td>CLONE_NEWCGROUP</td><td>Cgroup root directory</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>System V IPC, POSIX message queues</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>Network devices, stacks, ports, etc.</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>Mount points</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>Process IDs</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>User and group IDs</td></tr><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>Hostname and NIS domain name</td></tr></tbody></table><p>The kernel assigns each process a symbolic link per namespace kind in <code>/proc/&lt;pid>/ns/</code>. The inode number pointed to by this symlink is the same for each process in this namespace. This uniquely identifies each namespace by the inode number pointed to by one of its symlinks.</p><p>Reading the symlink via readlink returns a string containing the namespace kind name and the inode number of the namespace.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=cgroups>CGroups</h1><p>cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.</p><h4 id=resource-limiting>Resource limiting</h4><p>groups can be set to not exceed a configured memory limit</p><h4 id=prioritization>Prioritization</h4><p>Some groups may get a larger share of CPU utilization or disk I/O throughput</p><h4 id=accounting>Accounting</h4><p>Measures a group&rsquo;s resource usage, which may be used</p><h4 id=control>Control</h4><p><a href=https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt target=_blank>Freezing</a> groups of processes, their checkpointing and restarting</p><p>You can read and explore more about cGroups in this <a href=https://www.digitalocean.com/community/tutorials/how-to-limit-resources-using-cgroups-on-centos-6 target=_blank>post</a></p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=container-from-scratch>Container from scratch</h1><p>Using namespaces , we can start a process which will be completely isolated from other processes running in the system.</p><h3 id=create-root-file-system>Create root File System</h3><h4 id=create-directory-to-store-rootfs-contents>Create directory to store rootfs contents</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mkdir -p /root/busybox/rootfs
</span></span><span class=line><span class=cl>$ <span class=nv>CONTAINER_ROOT</span><span class=o>=</span>/root/busybox/rootfs
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> <span class=si>${</span><span class=nv>CONTAINER_ROOT</span><span class=si>}</span></span></span></code></pre></div><h4 id=download-busybox-binary>Download busybox binary</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ wget https://busybox.net/downloads/binaries/1.28.1-defconfig-multiarch/busybox-x86_64</span></span></code></pre></div><h4 id=create-needed-directories-and-symlinks>Create needed directories and symlinks</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mv busybox-x86_64 busybox
</span></span><span class=line><span class=cl>$ chmod <span class=m>755</span> busybox
</span></span><span class=line><span class=cl>$ mkdir bin
</span></span><span class=line><span class=cl>$ mkdir proc
</span></span><span class=line><span class=cl>$ mkdir sys
</span></span><span class=line><span class=cl>$ mkdir tmp
</span></span><span class=line><span class=cl>$ <span class=k>for</span> i in <span class=k>$(</span>./busybox --list<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>   ln -s /busybox bin/<span class=nv>$i</span>
</span></span><span class=line><span class=cl><span class=k>done</span></span></span></code></pre></div><h3 id=start-container>Start Container</h3><h4 id=start-a-shell-in-new-contianer>Start a shell in new contianer</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ unshare --mount --uts --ipc --net --pid --fork --user --map-root-user chroot <span class=si>${</span><span class=nv>CONTAINER_ROOT</span><span class=si>}</span> /bin/sh</span></span></code></pre></div><h4 id=mount-essential-kernel-structures>Mount essential kernel structures</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mount -t proc none /proc
</span></span><span class=line><span class=cl>$ mount -t sysfs none /sys
</span></span><span class=line><span class=cl>$ mount -t tmpfs none /tmp</span></span></code></pre></div><h3 id=configure-networking>Configure networking</h3><h4 id=from-host-system--create-a-veth-pair-and-then-map-that-to-container>From Host system , create a veth pair and then map that to container</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ip link add vethlocal <span class=nb>type</span> veth  peer name vethNS
</span></span><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> vethlocal up
</span></span><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> vethNS up
</span></span><span class=line><span class=cl>$ sudo ps -ef <span class=p>|</span>grep <span class=s1>&#39;/bin/sh&#39;</span>
</span></span><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> vethNS netns &lt;pid of /bin/sh&gt;</span></span></code></pre></div><h4 id=from-container--execute-ip-link>From container , execute <code>ip link</code></h4><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=what-is-docker>What is Docker</h1><p>Docker is a tool designed to make it easier to create, deploy, and run applications by using containers. Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and ship it all out as one package.</p><p>In a way, Docker is a bit like a virtual machine. But unlike a virtual machine, rather than creating a whole virtual operating system, Docker allows applications to use the same Linux kernel as the system that they&rsquo;re running on and only requires applications be shipped with things not already running on the host computer. This gives a significant performance boost and reduces the size of the application.</p><p><img src=../01-introduction/05-docker/docker.jpg alt=Kernel class="figure-image nobg-white noborder nolightbox shadow" style=height:auto;width:auto loading=lazy></p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=kubernetes>Kubernetes</h1><h3 id=pet-vs-cattle>Pet vs Cattle.</h3><p>In the pets service model, each pet server is given a loving names like zeus, ares, hades, poseidon, and athena. They are “unique, lovingly hand-raised, and cared for, and when they get sick, you nurse them back to health”. You scale these up by making them bigger, and when they are unavailable, everyone notices.</p><p>In the cattle service model, the servers are given identification numbers like web-01, web-02, web-03, web-04, and web-05, much the same way cattle are given numbers tagged to their ear. Each server is “almost identical to each other” and “when one gets sick, you replace it with another one”. You scale these by creating more of them, and when one is unavailable, no one notices.</p><p>Kubernetes is a portable, extensible open-source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</p><p>Google open-sourced the Kubernetes project in 2014. Kubernetes builds upon a decade and a half of experience that Google has with running production workloads at scale, combined with best-of-breed ideas and practices from the community</p><p><a href=https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ target=_blank>Read More here</a></p><p><a href=#R-image-064982eea66cde2e049d22b7f1c08ff4 class=lightbox-link><img src="../01-introduction/06-kubernetes/kubernetes.svg?classes=shadow&amp;width=60pc" alt="Container and Kubernetes" class="figure-image bg-white border lightbox shadow" style=height:auto;width:60pc loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-064982eea66cde2e049d22b7f1c08ff4><img src="../01-introduction/06-kubernetes/kubernetes.svg?classes=shadow&amp;width=60pc" alt="Container and Kubernetes" class="lightbox-image bg-white border lightbox shadow" loading=lazy></a></p><h3 id=kubernetes-architecture>Kubernetes Architecture</h3><p><a href=#R-image-296496c37936e449435807c416967fe9 class=lightbox-link><img src="../01-introduction/06-kubernetes/kubernetes-architecture.png?classes=shadow" alt="Container and Kubernetes" class="figure-image bg-white border lightbox shadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-296496c37936e449435807c416967fe9><img src="../01-introduction/06-kubernetes/kubernetes-architecture.png?classes=shadow" alt="Container and Kubernetes" class="lightbox-image bg-white border lightbox shadow" loading=lazy></a></p><h4 id=container-runtime>Container runtime</h4><p>Docker , rkt , containerd or any OCI compliant runtime which will download image , configures network , mount volumes and assist container life cycle management.</p><h4 id=kubelet>kubelet</h4><p>Responsible for instructing container runtime to start , stop or modify a container</p><h4 id=kube-proxy>kube-proxy</h4><p>Manage service IPs and iptables rules</p><h4 id=kube-apiserver>kube-apiserver</h4><p>API server interacts with all other components in cluster
All client interactions will happen via API server</p><h4 id=kube-scheduler>kube-scheduler</h4><p>Responsible for scheduling workload on minions or worker nodes based on resource constraints</p><h4 id=kube-controller-manager>kube-controller-manager</h4><p>Responsible for monitoring different containers in reconciliation loop
Will discuss more about different controllers later in this course</p><h4 id=etcd>etcd</h4><p>Persistent store where we store all configurations and cluster state</p><h4 id=cloud-controller-manager>cloud-controller-manager</h4><p>Cloud vendor specific controller and cloud vendor is Responsible to develop this program</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=container-networking>Container Networking</h1><p>We need to access the container from outside world and the container running on different hosts have to communicate each other.</p><p>Here we will see how can we do it with bridging.</p><h4 id=traditional-networking>Traditional networking</h4><p><a href=#R-image-83be936af3eeb8447178555bc7ce8857 class=lightbox-link><img src="../01-introduction/07-network-plugins/nw-traditional.png?classes=shadow" alt=Network class="figure-image bg-white border lightbox shadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-83be936af3eeb8447178555bc7ce8857><img src="../01-introduction/07-network-plugins/nw-traditional.png?classes=shadow" alt=Network class="lightbox-image bg-white border lightbox shadow" loading=lazy></a></p><h4 id=create-a-veth-pair-on-host>Create a veth pair on Host.</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ip link add veth0 <span class=nb>type</span> veth peer name veth1
</span></span><span class=line><span class=cl>$ sudo ip link show</span></span></code></pre></div><h4 id=create-a-network-namespace>Create a network namespace</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ip netns add bash-nw-namespace
</span></span><span class=line><span class=cl>$ sudo ip netns show</span></span></code></pre></div><h4 id=connect-one-end-to-namespace>Connect one end to namespace</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> veth1 netns bash-nw-namespace
</span></span><span class=line><span class=cl>$ sudo ip link list</span></span></code></pre></div><h4 id=resulting-network>Resulting network</h4><p><a href=#R-image-dabeedfbc61e6c7a1904ce5699e50535 class=lightbox-link><img src="../01-introduction/07-network-plugins/nw-namespace.png?classes=shadow" alt=Network class="figure-image bg-white border lightbox shadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-dabeedfbc61e6c7a1904ce5699e50535><img src="../01-introduction/07-network-plugins/nw-namespace.png?classes=shadow" alt=Network class="lightbox-image bg-white border lightbox shadow" loading=lazy></a></p><h4 id=create-a-bridge-interface>Create a Bridge interface</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo brctl addbr cbr0</span></span></code></pre></div><h4 id=add-an-external-interface-to-bridge>Add an external interface to bridge</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo brctl addif cbr0 enp0s9
</span></span><span class=line><span class=cl>$ sudo brctl show</span></span></code></pre></div><h4 id=connect-other-end-to-a-switch>Connect other end to a switch</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo brctl addif cbr0 veth0
</span></span><span class=line><span class=cl>$ sudo brctl show</span></span></code></pre></div><h4 id=resulting-network-1>Resulting network</h4><p><a href=#R-image-35eb695d42f773458fd98d1922bff7fd class=lightbox-link><img src="../01-introduction/07-network-plugins/nw-namespace-with-bridge.png?classes=shadow" alt=Network class="figure-image bg-white border lightbox shadow" style=height:auto;width:auto loading=lazy></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-35eb695d42f773458fd98d1922bff7fd><img src="../01-introduction/07-network-plugins/nw-namespace-with-bridge.png?classes=shadow" alt=Network class="lightbox-image bg-white border lightbox shadow" loading=lazy></a></p><h4 id=assign-ip-to-interface>Assign IP to interface</h4><div class="wrap-code highlight"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo ip netns <span class=nb>exec</span> bash-nw-namespace bash
</span></span><span class=line><span class=cl>$ sudo ip addr add 192.168.56.10/24 dev veth1
</span></span><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> lo up
</span></span><span class=line><span class=cl>$ sudo ip link <span class=nb>set</span> dev veth1 up</span></span></code></pre></div><h4 id=access-container-ip-from-outside>Access container IP from outside</h4><p>Like bridging , we can opt other networking solutions.</p><p>Later we will see how Weave Network and Calico plugins works.
You may read bit more on Docker networking basics on below blog post</p><p><a href=https://blog.docker.com/2016/12/understanding-docker-networking-drivers-use-cases/ target=_blank>Docker networking</a></p><footer class=footline></footer></article></section></div></main></div><script src=../js/clipboard.min.js?1704656421 defer></script><script src=../js/perfect-scrollbar.min.js?1704656421 defer></script><script src=../js/theme.js?1704656421 defer></script></body></html>