<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Hugo Relearn Theme</title><link>https://kubernetes.ansilh.com/01-introduction/index.html</link><description>Recent content in Introduction on Hugo Relearn Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 29 Dec 2018 17:15:52 +0000</lastBuildDate><atom:link href="https://kubernetes.ansilh.com/01-introduction/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel Architecture</title><link>https://kubernetes.ansilh.com/01-introduction/01-linux-kernel/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/01-linux-kernel/index.html</guid><description>At the top is the user, or application, space. This is where the user applications are executed. Below the user space is the kernel space.
There is also the GNU C Library (glibc). This provides the system call interface that connects to the kernel and provides the mechanism to transition between the user-space application and the kernel. This is important because the kernel and user application occupy different protected address spaces.</description></item><item><title>Linux Namespaces</title><link>https://kubernetes.ansilh.com/01-introduction/02-namespaces/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/02-namespaces/index.html</guid><description>Namespaces are a feature of the Linux kernel that partitions kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same name space for these resources in the various sets of processes, but those names referring to distinct resources. Examples of resource names that can exist in multiple spaces, so that the named resources are partitioned, are process IDs, hostnames, user IDs, file names, and some names associated with network access, and interprocess communication.</description></item><item><title>CGroups</title><link>https://kubernetes.ansilh.com/01-introduction/03-cgroups/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/03-cgroups/index.html</guid><description>cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.
Resource limiting groups can be set to not exceed a configured memory limit
Prioritization Some groups may get a larger share of CPU utilization or disk I/O throughput
Accounting Measures a group&amp;rsquo;s resource usage, which may be used
Control Freezing groups of processes, their checkpointing and restarting</description></item><item><title>Container from scratch</title><link>https://kubernetes.ansilh.com/01-introduction/04-containers/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/04-containers/index.html</guid><description>Using namespaces , we can start a process which will be completely isolated from other processes running in the system.
Create root File System Create directory to store rootfs contents $ mkdir -p /root/busybox/rootfs $ CONTAINER_ROOT=/root/busybox/rootfs $ cd ${CONTAINER_ROOT}Download busybox binary $ wget https://busybox.net/downloads/binaries/1.28.1-defconfig-multiarch/busybox-x86_64Create needed directories and symlinks $ mv busybox-x86_64 busybox $ chmod 755 busybox $ mkdir bin $ mkdir proc $ mkdir sys $ mkdir tmp $ for i in $(.</description></item><item><title>What is Docker</title><link>https://kubernetes.ansilh.com/01-introduction/05-docker/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/05-docker/index.html</guid><description>Docker is a tool designed to make it easier to create, deploy, and run applications by using containers. Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and ship it all out as one package.
In a way, Docker is a bit like a virtual machine. But unlike a virtual machine, rather than creating a whole virtual operating system, Docker allows applications to use the same Linux kernel as the system that they&amp;rsquo;re running on and only requires applications be shipped with things not already running on the host computer.</description></item><item><title>Kubernetes</title><link>https://kubernetes.ansilh.com/01-introduction/06-kubernetes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/06-kubernetes/index.html</guid><description>Pet vs Cattle. In the pets service model, each pet server is given a loving names like zeus, ares, hades, poseidon, and athena. They are “unique, lovingly hand-raised, and cared for, and when they get sick, you nurse them back to health”. You scale these up by making them bigger, and when they are unavailable, everyone notices.
In the cattle service model, the servers are given identification numbers like web-01, web-02, web-03, web-04, and web-05, much the same way cattle are given numbers tagged to their ear.</description></item><item><title>Container Networking</title><link>https://kubernetes.ansilh.com/01-introduction/07-network-plugins/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kubernetes.ansilh.com/01-introduction/07-network-plugins/index.html</guid><description>We need to access the container from outside world and the container running on different hosts have to communicate each other.
Here we will see how can we do it with bridging.
Traditional networking Create a veth pair on Host. $ sudo ip link add veth0 type veth peer name veth1 $ sudo ip link showCreate a network namespace $ sudo ip netns add bash-nw-namespace $ sudo ip netns showConnect one end to namespace $ sudo ip link set veth1 netns bash-nw-namespace $ sudo ip link listResulting network Create a Bridge interface $ sudo brctl addbr cbr0Add an external interface to bridge $ sudo brctl addif cbr0 enp0s9 $ sudo brctl showConnect other end to a switch $ sudo brctl addif cbr0 veth0 $ sudo brctl showResulting network Assign IP to interface $ sudo ip netns exec bash-nw-namespace bash $ sudo ip addr add 192.</description></item></channel></rss>