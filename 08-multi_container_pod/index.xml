<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Multi-Container Pods on Hugo Relearn Theme</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/index.html</link><description>Recent content in Multi-Container Pods on Hugo Relearn Theme</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 29 Dec 2018 17:15:52 +0000</lastBuildDate><atom:link href="https://kubernetes.ansilh.com/08-multi_container_pod/index.xml" rel="self" type="application/rss+xml"/><item><title>InitContainer</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/03-init-container/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/03-init-container/index.html</guid><description>In this session , we will discuss about InitContainer
Non-persistent web server As we already know ,containers are ephemeral and the modifications will be lost when container is destroyed.
In this example , we will download webpages from Github repository and store it in a emptyDir volume.
From this emptyDir volume , we will serve the HTML pages using an Nginx Pod
emptyDir is a volume type , just like hostPath , but the contents of emptyDir will be destroyed when Pod is stopped.</description></item><item><title>Inject data to Pod</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/01-env-inject/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/01-env-inject/index.html</guid><description>Inject data to pod via Environmental variable We will create a Coffee Pod
$ kubectl run tea --image=ansilh/demo-tea --env=MY_NODE_NAME=scratch --restart=Never --dry-run -o yaml &amp;gt;pod-with-env.yamlapiVersion: v1 kind: Pod metadata: creationTimestamp: null labels: run: tea name: tea spec: containers: - env: - name: MY_NODE_NAME value: scratch image: ansilh/demo-tea name: coffee-new resources: {} dnsPolicy: ClusterFirst restartPolicy: Never status: {}Lets run this Pod
$ kubectl create -f pod-with-env.yaml$ kubectl get pods NAME READY STATUS RESTARTS AGE tea 1/1 Running 0 7sLets expose the pod as NodePort</description></item><item><title>Introduction to Volumes</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/02-volumes/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/02-volumes/index.html</guid><description>Persistent volumes When a Pod dies , all container&amp;rsquo;s contents will be destroyed and never preserved by default. Sometimes you need to store the contents persistently (for eg:- etcd pod)
Kubernetes have a Volumes filed in Pod spec , which can be used to mount a volume inside container.
Lets explain the volume specs
$ kubectl explain pod.spec.volumesSo when you write Yaml , you have to put volumes object in spec.</description></item><item><title>Pod - manual scheduling</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/05-manual-schedule/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/05-manual-schedule/index.html</guid><description>Node Selector Suppose you have a Pod which needs to be running on a Pod which is having SSD in it.
First we need to add a label to the node which is having SSD
$ kubectl label node k8s-worker-01 disktype=ssdNow we can write a Pod spec with nodeSelector
apiVersion: v1 kind: Pod metadata: name: nginx labels: env: test spec: containers: - name: nginx image: nginx nodeSelector: disktype: ssdScheduler will look at the node selector and select apropriate node to run the pod</description></item><item><title>Pod design patterns</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/04-pod-patterns/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/04-pod-patterns/index.html</guid><description>When the containers have the exact same lifecycle, or when the containers must run on the same node. The most common scenario is that you have a helper process that needs to be located and managed on the same node as the primary container.
Another reason to combine containers into a single pod is for simpler communication between containers in the pod. These containers can communicate through shared volumes (writing to a shared file or directory) and through inter-process communication (semaphores or shared memory).</description></item><item><title>Taints and Tolerations</title><link>https://kubernetes.ansilh.com/08-multi_container_pod/06-taints-and-tolerations/index.html</link><pubDate>Sat, 29 Dec 2018 17:15:52 +0000</pubDate><guid>https://kubernetes.ansilh.com/08-multi_container_pod/06-taints-and-tolerations/index.html</guid><description>You add a taint to a node using kubectl taint. For example,
$ kubectl taint nodes k8s-worker-02 key=value:NoScheduleplaces a taint on node node1. The taint has key key, value value, and taint effect NoSchedule. This means that no pod will be able to schedule onto node1 unless it has a matching toleration.
To remove the taint added by the command above, you can run:
kubectl taint nodes k8s-worker-02 key:NoSchedule-You specify a toleration for a pod in the PodSpec.</description></item></channel></rss>